T = int(input())
for tc in range(1, T+1):
    N= int(input())
    Ci = list(map(int, input().split()))
    Ci.sort()
    can = [] #당근의 포장 조건을 만족하는 개수 차이
    for i in range(1, N-1): # 첫 번쨰 상자와 두번 째 상자 사이
        for j in range(i+1, N): # 두번째 상자와 세번째상자사이
            A = Ci[:i] # 첫번째 상자
            B = Ci[i:j] # 두번째 상자
            C = Ci[j:] # 세번째 상자
            if A[-1] == B[0] or B[-1] == C[0]: # 같은 크기의 당근이 인접한 상자에 있으면
                continue
            if len(A) * len(B) * len(C) == 0: #빈상자가 있으면
                continue
            if len(A) > N//2 or len(B) > N//2 or len(C) > N//2:  # 한상자가 조건이상 초과하면
                continue
            # 상자간의 당근 개수의 차이 -> 최댓값
            can.append(max(abs(len(A) - len(B)), abs(len(B) - len(C)), abs(len(A) - len(C))))
    try:
        print(f"#{tc} {min(can)}")
    except:
        print(f"#{tc} -1")
# 첫번째 for문 돌아간 후
# [[[1], [2, 3, 4, 5, 6, 7, 8, 9]]
#     재귀함수
#  [[1], [2], [3, 4, 5, 6, 7, 8, 9]],
#  [[1], [2, 3], [4, 5, 6, 7, 8, 9]],
#  [[1], [2, 3, 4], [5, 6, 7, 8, 9]],
#  [[1], [2, 3, 4, 5], [6, 7, 8, 9]],
#  ......
#  [[1, 2], [3], [4, 5, 6, 7, 8, 9]],
#  [[1, 2], [3, 4], [5, 6, 7, 8, 9]],
#  [[1, 2], [3, 4, 5], [6, 7, 8, 9]],
#  [[1, 2], [3, 4, 5, 6], [7, 8, 9]],
#  .......
#  [[1, 2, 3], [4, 5, 6, 7, 8, 9]],
#  [[1, 2, 3, 4], [5, 6, 7, 8, 9]],
#  [[1, 2, 3, 4, 5], [6, 7, 8, 9]],
#  [[1, 2, 3, 4, 5, 6], [7, 8, 9]],
#  [[1, 2, 3, 4, 5, 6, 7], [8, 9]]]


