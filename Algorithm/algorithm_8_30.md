## 응용2. 완전검색 & 그리디

### 목차
- [반복과 재귀](#반복iteration과-재귀recursion)
- [완전검색기법]
- [순열]
- [부분집합]
- [조합]
- [탐욕 알고리즘]
- [활동 선택문제]
- [Baby-jin]

### 반복(Iteration)과 재귀(Recursion)
- 반복과 재귀는 유사한 작업을 수행 가능
- 반복은 수행하는 작업이 완료될 때까지 계속 반복
  - 루프(for, while 구조)
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
  - 하나의 큰 문제를 해결할 수 있는(해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합
  - 재귀 함수로 구현

#### 반복구조
1. 초기화
   - 반복되는 명령문을 실행하기 전에(한번만) 조건 검사에 사용할 변수의 초기값 설정
2. 조건검사(check control expression)
3. 반복할 명령문 실행(action)
4. 업데이트(loop update)
   - 무한 루프가 되지 않게 조건이 거짓(false)이 되도록 한다.

#### 반복을 이용한 선택정렬
- 예시
 ```py
 def SelectionSort(A):
    n = len(A)
    for i in range(0, n-1):
        minI = i
        for j in range(i+1, n):
            if A[j] < A[minI]:
                minI = j
        A[minI], A[i] = A[i], A[minI]
 ```

### 재귀적 알고리즘
- 재귀적 정의는 두 부분으로 나뉜다.
- 하나 또는 그 이상의 기본경우
  - 집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드(seed)역할
- 하나 또는 그 이상의 유도된 경우
  - 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법

### 재귀 함수(recursive function)
- 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
- 일반적으로 재귀적 정의를 이용해서 재귀 함수를 구현
- 따라서, 기본 부분(Basis part)와 유도 부분(inductive part)로 구성됨
- 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉽다
- 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다. 따라서 재귀호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하가 발생

#### 반복과 재귀 선택 방법
- 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스럽다.
  - 추상 자료형(list, tree 등)의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많다.
- 일반적으로 재귀적 알고리즘은 반복(Iterative) 알고리즘 보다 더 많은 메모리와 연산을 필요

- <span style = 'color:salmon'> 입력 값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적

#### 반복과 재귀의 비교
| |재귀 | 반복|
|---- |---- |---- |
|종료  |재귀 함수 호출이 종료되는 베이스케이스 | 반복문의 종료 조건 |
|수행시간 |(상대적)느림 |빠름 |
|메모리 공간 |(상대적)많이 사용 |적게 사용 |
| 소스 코드 길이|짧고 간결 |길다 |
|소스 코드 형태 |선택구조(if else) | 반복구조(for while)|
|무한 반복시 |스택 오버플로우 |CPU반복해서 점유 |

### 완전탐색(Brute Force)
- brute-force는 문제를 해결하기 위한 간단하고 쉬운 접근법이다.
  - Just do it
  - force의 의미는 사람보다는 컴퓨터의 force를 의미한다.
- 완전탐색 방법은 대부분의 문제에 적용 가능
- 상대적으로 빠른 시간에 알고리즘 설계를 할 수 있다.
- 문제에 포함된 자료(요소, 인스턴스)의 크기가 작다면 유용하다
- 모든 경우의 수를 생성하고 테스트하기 때문에 수행속도는 느리지만 해답을 찾아내지 못할 확률이 낮다.
  - 완전검색은 입력의 크기를 작게 해서 간편하고 빠르게 답을 구하는 프로그램을 작성
- 이를 기반으로 그리디 기법이나 DP(동적 계획법)을 이용해서 효율적인 알고리즘을 찾을 수 있다.
- <span style = 'color:salmon'>우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직

