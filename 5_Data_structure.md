### 2023_08_10(5장)

# CHAPTER 5 자료구조

## Section 1 복잡도

### 개요

- **복잡도**는 알고리즘의 성능을 나타내는 척도이다.   

- 복잡도는 **시간 복잡도**와 **공간 복잡도**로 나눌 수 있다.   

#### 시간 복잡도

- 특정한 크기의 입력에 대해 알고리즘이 얼마나 오래 걸리는지 의미
- 알고리즘을 위해 필요한 **연산의 횟수**

#### 공간 복잡도

- 특정한 크기의 입력에 대해 알고리즘이 얼마나 많은 메모리를 차지하는지 의미
- 알고리즘을 위해 필요한 **메모리의 양**

<details>
<summary>💡더 알아보기 :알고리즘의 성능 평가 Case</summary>

<!-- summary 아래 한칸 공백 두어야함 -->
- 최선의 경우(Best Case)
    - 최적의 입력을 한 상태에서, 작업을 완료하는데 가장 연산 횟수가 적은 경우
- 최악의 경우(Worst Case)
    - 최악의 입력을 한 상태에서, 작업을 완료하는데 가장 연산 횟수가 많은 경우
- 평균의 경우(Average Case)
    - 여러 경우의 수를 고려하여, 총 연산 횟수를 계산하고 시행 횟수로 나눈 경우

➡️ 알고리즘 분석 시 평균의 경우와 최악의 경우가 가장 많이 활용되며, 알고리즘이 복잡해질수록 평균을 구하기 어려워져 **최악의 경우**로 알고리즘 성능을 파악


</details>


### 5.1.1 시간 복잡도(Time Complexity)

알고리즘 문제를 풀 때 접하는 ‘복잡도’는 보통은 시간 복잡도를 의미한다.

시간 복잡도를 표현할 때는 [빅오 표기법](#빅오-표기법big-o-notation)을 사용한다.

### 5.1.2 공간 복잡도(Space Complexity)

앞서 시간 복잡도에서 1초라는 절대적인 제한이 있던 것처럼, 메모리 사용량에도 절대적인 제한이 존재한다.

일반적으로 메모리 사용량 기준은 MB단위로 제시된다. (코테문제에서 보이는 ‘시간제한 1초, 메모리제한 128MB’ 등이 시간복잡도와 공간복잡도를 제한하기 위해 명시하는 것)

### 빅오 표기법(Big-O notation)

빅오 표기법은 복잡도를 나타내는 점근 표기법 중 가장 많이 사용되는 표기법이다.

빅오 표기법이 가장 많이 사용되는 이유는 알고리즘 효율성을 상한선 기준으로 표기하기 때문이다.

다시 말해 **최악의 경우**를 고려하는 데 가장 좋은 표기법이다.

(알고리즘 효율성은 값이 클수록, 즉 그래프가 위로 향할수록 비효율적임을 의미)

### 빅오 표기법 형태

| 복잡도 | 소요 시간 | 예시 |
| --- | --- | --- |
| O(1) | 상수 시간 | 스택에서 Push, Pop |
| O(log n) | 로그 시간 | 이진 트리 |
| O(n) | 직선적 시간 | for 문 |
| O(n log n) | 선형 로그 시간 | 퀵 정렬(quick sort), 병합 정렬(merge sort), 힙 정렬(heap sort) |
| O(n^2) | 2차 시간 | 이중 for 문, 삽입 정렬(insertion sort), 거품 정렬(bubble sort), 선택 정렬(selection sort) |
| O(C^n) | 지수 시간 | 피보나치 수열 |

### Big O 시간 복잡도 속도 비교


 <img src="Big-O speed.png" width="50%" height="50%">

   - O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(C^n) 

   - (상로선다지/ 오른쪽으로 갈수록 시간 복잡도가 좋지 않은 알고리즘)

#### 빅오 표기법의 특징

- 상수항 및 영향력 없는 항 무시
    - O(2n) → **O(n)**
    - O(n^2 + 2n + 1) → **O(n^2)**


### 자료형 별 함수들의 시간 복잡도

- 자료형 정리

| 자료형 | 특징 | 표현 |
| --- | --- | --- |
| 리스트(List) | - 순서 O, 수정 가능(mutable) | list = [v1, v2, …] |
| 세트(Set) | - 순서 X, unique, mutable | set = {v1, v2, …} |
| 딕셔너리(Dictionary) | - 순서 X, 키(immutable), 값(mutable)이 맵핑 | dict = {k1:v1, k2:v2, …} |

<details>
<summary>리스트의 메서드별 시간 복잡도</summary>

<!-- summary 아래 한칸 공백 두어야함 -->

|  | Operation | Example | Big-O | Notes |
| --- | --- | --- | --- | --- |
| 1 | Index | l[i] | O(1) | 인덱스로 값 찾기 |
| 2 | Store | l[i] = val | O(1) | 인덱스로 데이터 저장 |
| 3 | Length | len(l) | O(1) | 리스트 길이 |
| 4 | Append | l.append(val) | O(1) | 리스트 뒤에 데이터 추가 |
| 5 | Pop | l.pop() | O(1) | 리스트 마지막 데이터 pop |
| 6 | Clear | l.clear() | O(1) | 빈 리스트로 만듬 |
| 7 | Slice | l[a:b] | O(b-a) | 슬라이싱 |
| 8 | Extend | l.extend(l2) | O(len(l2)) | 리스트 확장 |
| 9 | Construction | list(…) | O(len(…)) | 리스트 생성 |
| 10 | check ==, ≠ | l1 == l2 | O(N) | 비교 연산 |
| 11 | Insert | l[a:b] = … | O(N) | 데이터 삽입 |
| 12 | Delete | del l[i] | O(N) | 데이터 삭제 |
| 13 | Containment | x in/not in l | O(N) | x값 포함 여부 확인 |
| 14 | Copy | l.copy() | O(N) | 리스트 복제(얕은 복사) |
| 15 | Remove | l.remove(val) | O(N) | 리스트에서 val값 제거 |
| 16 | Pop | l.pop(i) | O(N) | i번째 인덱스 값 pop |
| 17 | Extreme value | min(l) / max(l) | O(N) | 전체 요소 중 최소/최대값 |
| 18 | Reverse | l.reverse() | O(N) | 뒤집기 |
| 19 | Iteration | for v in l: | O(N) | 전체 요소 순회 |
| 20 | Sort | l.sort() | O(N log N) | 파이썬 기본 정렬 |
| 21 | Multiply | k*l | O(k N) |  |

</details>
  
<details>
<summary>세트의 메서드별 시간 복잡도</summary>

<!-- summary 아래 한칸 공백 두어야함 -->
|  | Operation | Example | Big-O | Notes |
| --- | --- | --- | --- | --- |
| 1 | Add | s.add(val) | O(1) | 집합 요소 추가 |
| 2 | Containment | x in/not in s | O(1) | 포함 여부 확인 |
| 3 | Remove | s.remove(val) | O(1) | 요소 제거(없으면 에러) |
| 4 | Discard | s.discard(val) | O(1) | 요소 제거(없어도 에러x) |
| 5 | Pop | s.pop() | O(1) | 랜덤하게 하나 pop |
| 6 | Clear | s.clear() | O(1) | 세트 클리어 |
| 7 | Construction | set(…) | O(len(…)) | 길이만큼 |
| 8 | check ==, != | s != t | O(len(s)) | 비교 연산 |
| 9 | <= or < | s <= t | O(len(s)) | 부분집합 여부 |
| 10 | Union | s | t | O(len(s)+len(t)) | 합집합 |
| 11 | Intersection | s & t | O(len(s)+len(t)) | 교집합 |
| 12 | Difference | s - t | O(len(s)+len(t)) | 차집합 |
| 13 | Symmetric Diff | s ^ t | O(len(s)+len(t)) | 여집합 |
| 14 | Iteration | for v in s: | O(N) | 전체 요소 순회 |
| 15 | Copy | s.copy() | O(N) | 세트 복사 |

</details>
    
<details>
<summary>딕셔너리의 메서드별 시간 복잡도</summary>

<!-- summary 아래 한칸 공백 두어야함 -->
|   | Operation | Example | Big-O | Notes |
| --- | --- | --- | --- | --- |
| 1 | Store | d[k] = v | O(1) | 집합 요소 추가 |
| 2 | Length | len(d) | O(1) | 키/값 쌍 개수 |
| 3 | Delete | del d[k] | O(1) | 해당 key 제거 |
| 4 | get/setdefault | d.get(k) | O(1) | key에 따른 value 확인 |
| 5 | Pop | d.pop(k) | O(1) | 키/값 쌍 pop |
| 6 | Pop item | d.popitem() | O(1) | 랜덤 데이터(key:value) pop |
| 7 | Clear | d.clear() | O(1) |  딕셔너리 초기화 |
| 8 | View | d.keys() | O(1) | key 전체 확인 |
| 9 | Values | d.values() | O(1) | value 전체 확인 |
| 10 | Construction | dict(…) | O(len(…)) | (key, value) tuple 갯수만큼 |
| 11 | Iteration | for k in d: | O(N) | 딕셔너리 전체 순회 |

</details>


## Section 2 선형 자료 구조
- 요소가 일렬로 나열되어 있는 구조
  
### 연결 리스트 
- 여러 곳의 자료를 연결 한 것
- 배열처럼 선형 자료 구조 but 연속한 메모리 위치의 값이 저장되는 것은 아님
- 삽입과 삭제에 O(1), 탐색에는 O(n)의 시간
- [과일로 설명한 연결 리스트(파이썬)](https://velog.io/@9e0na/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%B4%EC%A4%91-%EC%9B%90%ED%98%95-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8)

#### 연결 리스트의 특징
- 동적 배열
- 삽입과 삭제가 용이
- 스택(stack), 큐(queue)등의 자료 구조를 만들 때 사용


#### 연결 리스트의 종류와 특징
- **싱글 연결 리스트**
  - 각 노드가 데이터와 다음 노드를 가리키는 포인터(링크)로 이루어진 연결 리스트
  - 리스트의 끝은 보통 None 또는 Null로 표시
  - 데이터를 순차적으로 탐색할 때 효율적
    - **장점**
      - 삽입과 삭제 연산이 O(1)에 가능
      - 메모리 효율적으로 사용가능
    - **단점**
      - 역방향 탐색이 어려워 역방향으로 데이터를 접근하려면 O(n)의 시간이 소요

- **이중연결 리스트**
  - 각 노드가 데이터, 이전 노드를 가리키는 포인터, 다음 노드를 가리키는 포인터로 이루어진 연결 리스트
    - **장점**
      - 양방향 탐색이 가능하여 역방향 탐색도 O(1) 시간에 가능
      - 중간 노드에서의 삽입 및 삭제 연산도 O(1) 시간에 가능
    - **단점**
      - 추가적인 포인터 때문에 메모리 사용량이 싱글 연결 리스트보다 많이 소요
- **원형 이중 연결 리스트**
  - 이중 연결 리스트의 마지막 노드가 첫 번쨰 노드를 가리키는 원형 구조
    - **장점**
      - 순차적인 루프 연산에 유용
      - 리스트를 순환하며 데이터를 처리할 때 효과적
    - **단점**
      - 원형 구조 때문에 종료 조건을 명확히 설정하지 않으면 무한 루프에 빠질 수 있음

### 배열
- 같은 타입의 변수들로 이루어져 있고 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
- 중복을 허용하며 순서가 존재
- 탐색에 O(1), 랜덤접근 가능, 삽입과 삭제에 O(n)의 시간
  - 단 정적배열 기준이며 파이썬에는 정적배열이 따로 존재하지는 않는다.

#### 배열과 연결리스트의 차이
| | 차이| 시간|
|----|-----|----|
|배열| 랜덤접근 O| O(1)|
|    | 삽입과 삭제가 느림| O(n)|
|연결리스트| 랜덤접근 X|O(n)|
|    |삽입과 삭제가 빠름|O(1)|

### 벡터
- 동적으로 요소를 할당할 수 있는 동적배열
- 중복을 허용, 순서가 있고 랜덤접근 가능
- 탐색과 요소의 삭제, 삽입에 O(1)의 시간
- 맨 뒤와 맨 앞 요소가 아니라면 O(n)

### 스택과 큐
#### 스택
- 함수 호출(Call Stack)에서 사용됨. 함수가 호출될 때 스택에 함수 호출 정보를 저장(append)하고, 함수가 반환될 때 해당 정보를 제거(pop)
- 임시 데이터 저장, 역순 문자열 처리 등 다양한 작업에 유용
- 특징
  - 후입선출(LIFO, Last-In-First-Out)
  - 데이터는 항상 스택의 맨 위에 추가되거나 제거
  - 주로 리스트(List) 자료형을 사용하여 구현
- 장점
  - 간단하고 빠른 데이터 추가 및 제거
  - 공간 효율적
- 단점
  - 중간에 있는 요소에 접근하기 어려움
  - 일반적으로 제한된 용량을 가짐

#### 큐
- 작업대기열(인터넷 대기열 등)에서 사용
- 데이터의 처리 순서가 중요한 경우에 유용
- 특징
  - 선입선출(FIFO, First-In-First-Out)
  - 데이터는 큐의 뒤에서 추가(append), 앞에서 제거(pop(o))
- 장점
  - 데이터의 처리 순서를 지켜야 할 때 유용
  - 중간에 있는 요소에도 접근 가능
- 단점
  - 요소를 중간에서 추가 또는 제거할 때 오버헤드가 발생할 수 있음
  - 큐의 용량 제한을 넘지 못할 수 있음

#### Reference

- [파이썬 시간 복잡도](https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt)